//+------------------------------------------------------------------+
//|                              Advanced_Reversal_Signal_System.mq5 |
//|                                    Multi-Level Trading Indicator |
//|                          Copyright 2025, Hamoon Algo Systems Ltd |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Hamoon Algo Ltd"
#property link      ""
#property version   "2.00"
#property description "Advanced Reversal Signal System v2.0"
#property indicator_separate_window
#property indicator_buffers 24
#property indicator_plots   15

// RSI Main Line
#property indicator_label1  "RSI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDodgerBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  3

// Bollinger Bands on RSI
#property indicator_label2  "BB Upper"
#property indicator_type2   DRAW_LINE
#property indicator_color2  clrCrimson
#property indicator_style2  STYLE_DOT
#property indicator_width2  2

#property indicator_label3  "BB Middle"
#property indicator_type3   DRAW_LINE
#property indicator_color3  clrGold
#property indicator_style3  STYLE_DOT
#property indicator_width3  1

#property indicator_label4  "BB Lower"
#property indicator_type4   DRAW_LINE
#property indicator_color4  clrLimeGreen
#property indicator_style4  STYLE_DOT
#property indicator_width4  2

// Z-Score Dynamic Levels
#property indicator_label5  "Z-Score +2σ"
#property indicator_type5   DRAW_LINE
#property indicator_color5  clrMagenta
#property indicator_style5  STYLE_DASHDOT
#property indicator_width5  1

#property indicator_label6  "Z-Score -2σ"
#property indicator_type6   DRAW_LINE
#property indicator_color6  clrMagenta
#property indicator_style6  STYLE_DASHDOT
#property indicator_width6  1

#property indicator_label7  "Z-Score Mean"
#property indicator_type7   DRAW_LINE
#property indicator_color7  clrSilver
#property indicator_style7  STYLE_DASH
#property indicator_width7  1

// RSI Fractal Patterns
#property indicator_label8  "Fractal Bullish"
#property indicator_type8   DRAW_ARROW
#property indicator_color8  clrAqua
#property indicator_width8  2

#property indicator_label9  "Fractal Bearish"
#property indicator_type9   DRAW_ARROW
#property indicator_color9  clrOrangeRed
#property indicator_width9  2

// Buy Signal Hierarchy (3 Levels)
#property indicator_label10  "Buy Signal Level 1"
#property indicator_type10   DRAW_ARROW
#property indicator_color10  clrLightGreen
#property indicator_width10  2

#property indicator_label11  "Buy Signal Level 2"
#property indicator_type11   DRAW_ARROW
#property indicator_color11  clrLime
#property indicator_width11  4

#property indicator_label12  "Buy Signal Level 3"
#property indicator_type12   DRAW_ARROW
#property indicator_color12  clrDarkGreen
#property indicator_width12  5

// Sell Signal Hierarchy (3 Levels)
#property indicator_label13  "Sell Signal Level 1"
#property indicator_type13   DRAW_ARROW
#property indicator_color13  clrLightCoral
#property indicator_width13  2

#property indicator_label14  "Sell Signal Level 2"
#property indicator_type14   DRAW_ARROW
#property indicator_color14  clrOrangeRed
#property indicator_width14  4

#property indicator_label15  "Sell Signal Level 3"
#property indicator_type15   DRAW_ARROW
#property indicator_color15  clrDarkRed
#property indicator_width15  5

// Enhanced Input Parameters
input group "═══════ RSI Settings ═══════"
input int InpRSIPeriod = 14;                          // RSI Period
input ENUM_APPLIED_PRICE InpRSIPrice = PRICE_CLOSE;   // RSI Applied Price
input int InpRSISmoothPeriod = 3;                     // RSI Smoothing Period (1=no smoothing)

input group "═══════ Bollinger Bands Settings ═══════"
input int InpBBPeriod = 20;                           // BB Period
input double InpBBDeviation = 2.0;                    // BB Standard Deviation
input ENUM_MA_METHOD InpBBMethod = MODE_SMA;          // BB Moving Average Method

input group "═══════ Z-Score Settings ═══════"
input int InpZScorePeriod = 20;                       // Z-Score Lookback Period
input double InpZScoreThreshold = 2.0;                // Z-Score Threshold (σ)
input bool InpZScoreDynamic = true;                   // Use Dynamic Z-Score

input group "═══════ Fractal Settings ═══════"
input int InpFractalPeriod = 5;                       // Fractal Period (minimum 5)
input bool InpFractalConfirm = true;                  // Require Fractal Confirmation

input group "═══════ Signal Generation ═══════"
input bool InpShowBBSignals = true;                   // Enable Bollinger Band Signals
input bool InpShowZScoreSignals = true;               // Enable Z-Score Signals
input bool InpShowFractalSignals = true;              // Enable Fractal Signals
input bool InpShowDivergence = true;                  // Enable Divergence Detection
input int InpSignalValidityBars = 5;                  // Signal Validity Period (bars)

input group "═══════ Visual Settings ═══════"
input bool InpShowChartSignals = true;                // Display Signals on Main Chart
input int InpSignalArrowSize = 3;                     // Chart Arrow Size
input bool InpShowTextLabels = true;                  // Show Text Labels
input bool InpShowAlerts = true;                      // Enable Alerts
input int InpFontSize = 9;                            // Text Label Font Size
input color InpBuyTextColor = clrLime;                // Buy Text Color
input color InpSellTextColor = clrRed;                // Sell Text Color

// Global Indicator Buffers
double RSIBuffer[];
double RSISmoothedBuffer[];
double BBUpperBuffer[];
double BBMiddleBuffer[];
double BBLowerBuffer[];
double ZScoreUpperBuffer[];
double ZScoreLowerBuffer[];
double ZScoreMeanBuffer[];
double FractalUpBuffer[];
double FractalDownBuffer[];
double BuySignal1Buffer[];
double BuySignal2Buffer[];
double BuySignal3Buffer[];
double SellSignal1Buffer[];
double SellSignal2Buffer[];
double SellSignal3Buffer[];

// Working/Calculation Buffers
double RSIWorkBuffer[];
double BBStdDevBuffer[];
double ZScoreMeanWork[];
double ZScoreStdDevWork[];
double PriceHighBuffer[];
double PriceLowBuffer[];
double DivergenceWork[];
double SignalStrengthBuffer[];

// Global Variables
datetime LastAlertTime = 0;
int CalculatedBars = 0;

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
{
    // Validate Input Parameters
    if(InpRSIPeriod < 2)
    {
        Print("ERROR: RSI Period must be >= 2. Current value: ", InpRSIPeriod);
        return(INIT_PARAMETERS_INCORRECT);
    }
    if(InpBBPeriod < 2)
    {
        Print("ERROR: Bollinger Bands Period must be >= 2. Current value: ", InpBBPeriod);
        return(INIT_PARAMETERS_INCORRECT);
    }
    if(InpZScorePeriod < 2)
    {
        Print("ERROR: Z-Score Period must be >= 2. Current value: ", InpZScorePeriod);
        return(INIT_PARAMETERS_INCORRECT);
    }
    if(InpFractalPeriod < 5 || InpFractalPeriod % 2 == 0)
    {
        Print("ERROR: Fractal Period must be >= 5 and odd number. Current value: ", InpFractalPeriod);
        return(INIT_PARAMETERS_INCORRECT);
    }
    if(InpRSISmoothPeriod < 1)
    {
        Print("ERROR: RSI Smooth Period must be >= 1. Current value: ", InpRSISmoothPeriod);
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    // Set Data Buffers (displayed on chart)
    SetIndexBuffer(0, RSISmoothedBuffer, INDICATOR_DATA);
    SetIndexBuffer(1, BBUpperBuffer, INDICATOR_DATA);
    SetIndexBuffer(2, BBMiddleBuffer, INDICATOR_DATA);
    SetIndexBuffer(3, BBLowerBuffer, INDICATOR_DATA);
    SetIndexBuffer(4, ZScoreUpperBuffer, INDICATOR_DATA);
    SetIndexBuffer(5, ZScoreLowerBuffer, INDICATOR_DATA);
    SetIndexBuffer(6, ZScoreMeanBuffer, INDICATOR_DATA);
    SetIndexBuffer(7, FractalUpBuffer, INDICATOR_DATA);
    SetIndexBuffer(8, FractalDownBuffer, INDICATOR_DATA);
    SetIndexBuffer(9, BuySignal1Buffer, INDICATOR_DATA);
    SetIndexBuffer(10, BuySignal2Buffer, INDICATOR_DATA);
    SetIndexBuffer(11, BuySignal3Buffer, INDICATOR_DATA);
    SetIndexBuffer(12, SellSignal1Buffer, INDICATOR_DATA);
    SetIndexBuffer(13, SellSignal2Buffer, INDICATOR_DATA);
    SetIndexBuffer(14, SellSignal3Buffer, INDICATOR_DATA);
    
    // Set Calculation Buffers (internal use only)
    SetIndexBuffer(15, RSIBuffer, INDICATOR_CALCULATIONS);
    SetIndexBuffer(16, RSIWorkBuffer, INDICATOR_CALCULATIONS);
    SetIndexBuffer(17, BBStdDevBuffer, INDICATOR_CALCULATIONS);
    SetIndexBuffer(18, ZScoreMeanWork, INDICATOR_CALCULATIONS);
    SetIndexBuffer(19, ZScoreStdDevWork, INDICATOR_CALCULATIONS);
    SetIndexBuffer(20, PriceHighBuffer, INDICATOR_CALCULATIONS);
    SetIndexBuffer(21, PriceLowBuffer, INDICATOR_CALCULATIONS);
    SetIndexBuffer(22, DivergenceWork, INDICATOR_CALCULATIONS);
    SetIndexBuffer(23, SignalStrengthBuffer, INDICATOR_CALCULATIONS);
    
    // Set Arrow Codes
    PlotIndexSetInteger(7, PLOT_ARROW, 217);   // Fractal Up - Circle
    PlotIndexSetInteger(8, PLOT_ARROW, 218);   // Fractal Down - Circle
    PlotIndexSetInteger(9, PLOT_ARROW, 233);   // Buy Level 1 - Small Up Arrow
    PlotIndexSetInteger(10, PLOT_ARROW, 241);  // Buy Level 2 - Medium Up Arrow
    PlotIndexSetInteger(11, PLOT_ARROW, 226);  // Buy Level 3 - Large Up Triangle
    PlotIndexSetInteger(12, PLOT_ARROW, 234);  // Sell Level 1 - Small Down Arrow
    PlotIndexSetInteger(13, PLOT_ARROW, 242);  // Sell Level 2 - Medium Down Arrow
    PlotIndexSetInteger(14, PLOT_ARROW, 225);  // Sell Level 3 - Large Down Triangle
    
    // Set Empty Values for Arrow Plots
    for(int i = 7; i <= 14; i++)
    {
        PlotIndexSetDouble(i, PLOT_EMPTY_VALUE, 0);
    }
    
    // Set Plot Labels with Signal Strength
    PlotIndexSetString(9, PLOT_LABEL, "BUY L1 (Weak)");
    PlotIndexSetString(10, PLOT_LABEL, "BUY L2 (Medium)");
    PlotIndexSetString(11, PLOT_LABEL, "BUY L3 (Strong)");
    PlotIndexSetString(12, PLOT_LABEL, "SELL L1 (Weak)");
    PlotIndexSetString(13, PLOT_LABEL, "SELL L2 (Medium)");
    PlotIndexSetString(14, PLOT_LABEL, "SELL L3 (Strong)");
    
    // Set Indicator Name
    string shortName = StringFormat("RSI Multi-Signal System [%d,%d,%d]", 
                                    InpRSIPeriod, InpBBPeriod, InpZScorePeriod);
    IndicatorSetString(INDICATOR_SHORTNAME, shortName);
    
    // Set Indicator Levels
    IndicatorSetInteger(INDICATOR_LEVELS, 5);
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, 80);
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, 70);
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 2, 50);
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 3, 30);
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 4, 20);
    
    // Set Level Colors
    IndicatorSetInteger(INDICATOR_LEVELCOLOR, 0, clrDarkRed);
    IndicatorSetInteger(INDICATOR_LEVELCOLOR, 1, clrGray);
    IndicatorSetInteger(INDICATOR_LEVELCOLOR, 2, clrGray);
    IndicatorSetInteger(INDICATOR_LEVELCOLOR, 3, clrGray);
    IndicatorSetInteger(INDICATOR_LEVELCOLOR, 4, clrDarkGreen);
    
    // Set Level Styles
    IndicatorSetInteger(INDICATOR_LEVELSTYLE, 0, STYLE_DASHDOT);
    IndicatorSetInteger(INDICATOR_LEVELSTYLE, 1, STYLE_DOT);
    IndicatorSetInteger(INDICATOR_LEVELSTYLE, 2, STYLE_SOLID);
    IndicatorSetInteger(INDICATOR_LEVELSTYLE, 3, STYLE_DOT);
    IndicatorSetInteger(INDICATOR_LEVELSTYLE, 4, STYLE_DASHDOT);
    
    // Set Indicator Digits
    IndicatorSetInteger(INDICATOR_DIGITS, 2);
    
    // Set Indicator Minimum and Maximum
    IndicatorSetDouble(INDICATOR_MINIMUM, 0);
    IndicatorSetDouble(INDICATOR_MAXIMUM, 100);
    
    Print("RSI Multi-Signal System initialized successfully");
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
    // Check if we have enough data
    int minBars = InpRSIPeriod + InpBBPeriod + InpZScorePeriod + InpFractalPeriod;
    if(rates_total < minBars)
    {
        Print("Not enough bars. Required: ", minBars, " Available: ", rates_total);
        return(0);
    }
    
    // Determine starting position for calculations
    int startPos = prev_calculated > 0 ? prev_calculated - 1 : 0;
    
    // Recalculate last N bars for accuracy
    if(prev_calculated > InpSignalValidityBars)
        startPos = prev_calculated - InpSignalValidityBars;
    
    // Store price data for divergence detection
    ArrayCopy(PriceHighBuffer, high);
    ArrayCopy(PriceLowBuffer, low);
    
    // Step 1: Calculate RSI
    CalculateRSI(rates_total, startPos, close);
    
    // Step 2: Apply smoothing to RSI if enabled
    if(InpRSISmoothPeriod > 1)
        SmoothRSI(rates_total, startPos);
    else
        ArrayCopy(RSISmoothedBuffer, RSIBuffer);
    
    // Step 3: Calculate Bollinger Bands on RSI
    CalculateBollingerBands(rates_total, startPos);
    
    // Step 4: Calculate Z-Score boundaries
    CalculateZScore(rates_total, startPos);
    
    // Step 5: Identify Fractal patterns on RSI
    CalculateFractals(rates_total, startPos);
    
    // Step 6: Detect divergences between price and RSI
    if(InpShowDivergence)
        DetectDivergences(rates_total, startPos, high, low);
    
    // Step 7: Generate multi-level trading signals
    GenerateAdvancedSignals(rates_total, startPos);
    
    // Step 8: Draw visual elements on main chart
    if(InpShowChartSignals)
        DrawEnhancedChartSignals(rates_total, startPos, time, high, low, close);
    
    // Step 9: Trigger alerts for new signals
    if(InpShowAlerts)
        CheckAndTriggerAlerts(rates_total, time);
    
    CalculatedBars = rates_total;
    
    return(rates_total);
}

//+------------------------------------------------------------------+
//| Calculate RSI with Wilder's smoothing method                     |
//+------------------------------------------------------------------+
void CalculateRSI(const int rates_total, const int start, const double &price[])
{
    static double prevAvgGain = 0;
    static double prevAvgLoss = 0;
    
    for(int i = start; i < rates_total; i++)
    {
        if(i < InpRSIPeriod)
        {
            RSIBuffer[i] = 50.0;
            continue;
        }
        
        // Initial calculation for first RSI value
        if(i == InpRSIPeriod)
        {
            double sumGain = 0, sumLoss = 0;
            
            for(int j = 1; j <= InpRSIPeriod; j++)
            {
                double change = price[i - j + 1] - price[i - j];
                if(change > 0)
                    sumGain += change;
                else
                    sumLoss += MathAbs(change);
            }
            
            prevAvgGain = sumGain / InpRSIPeriod;
            prevAvgLoss = sumLoss / InpRSIPeriod;
        }
        else
        {
            // Wilder's smoothing method for subsequent values
            double change = price[i] - price[i - 1];
            double currentGain = (change > 0) ? change : 0;
            double currentLoss = (change < 0) ? MathAbs(change) : 0;
            
            prevAvgGain = (prevAvgGain * (InpRSIPeriod - 1) + currentGain) / InpRSIPeriod;
            prevAvgLoss = (prevAvgLoss * (InpRSIPeriod - 1) + currentLoss) / InpRSIPeriod;
        }
        
        // Calculate RSI
        if(prevAvgLoss == 0)
            RSIBuffer[i] = 100.0;
        else
        {
            double rs = prevAvgGain / prevAvgLoss;
            RSIBuffer[i] = 100.0 - (100.0 / (1.0 + rs));
        }
    }
}

//+------------------------------------------------------------------+
//| Apply smoothing to RSI                                           |
//+------------------------------------------------------------------+
void SmoothRSI(const int rates_total, const int start)
{
    for(int i = start; i < rates_total; i++)
    {
        if(i < InpRSIPeriod + InpRSISmoothPeriod - 1)
        {
            RSISmoothedBuffer[i] = RSIBuffer[i];
            continue;
        }
        
        double sum = 0;
        for(int j = 0; j < InpRSISmoothPeriod; j++)
            sum += RSIBuffer[i - j];
        
        RSISmoothedBuffer[i] = sum / InpRSISmoothPeriod;
    }
}

//+------------------------------------------------------------------+
//| Calculate Bollinger Bands on RSI with selectable MA method       |
//+------------------------------------------------------------------+
void CalculateBollingerBands(const int rates_total, const int start)
{
    for(int i = start; i < rates_total; i++)
    {
        if(i < InpRSIPeriod + InpBBPeriod - 1)
        {
            BBUpperBuffer[i] = 0;
            BBMiddleBuffer[i] = 0;
            BBLowerBuffer[i] = 0;
            continue;
        }
        
        // Calculate Moving Average based on selected method
        double ma = 0;
        
        switch(InpBBMethod)
        {
            case MODE_SMA:
            {
                double sum = 0;
                for(int j = 0; j < InpBBPeriod; j++)
                    sum += RSISmoothedBuffer[i - j];
                ma = sum / InpBBPeriod;
                break;
            }
            case MODE_EMA:
            {
                double k = 2.0 / (InpBBPeriod + 1.0);
                ma = RSISmoothedBuffer[i];
                for(int j = 1; j < InpBBPeriod; j++)
                    ma = RSISmoothedBuffer[i - j] * k + ma * (1 - k);
                break;
            }
            case MODE_SMMA:
            {
                double sum = 0;
                for(int j = 0; j < InpBBPeriod; j++)
                    sum += RSISmoothedBuffer[i - j];
                ma = sum / InpBBPeriod;
                if(i > InpRSIPeriod + InpBBPeriod)
                    ma = (BBMiddleBuffer[i - 1] * (InpBBPeriod - 1) + RSISmoothedBuffer[i]) / InpBBPeriod;
                break;
            }
            case MODE_LWMA:
            {
                double sum = 0;
                double weightSum = 0;
                for(int j = 0; j < InpBBPeriod; j++)
                {
                    int weight = InpBBPeriod - j;
                    sum += RSISmoothedBuffer[i - j] * weight;
                    weightSum += weight;
                }
                ma = sum / weightSum;
                break;
            }
        }
        
        BBMiddleBuffer[i] = ma;
        
        // Calculate Standard Deviation
        double sumSq = 0;
        for(int j = 0; j < InpBBPeriod; j++)
        {
            double diff = RSISmoothedBuffer[i - j] - ma;
            sumSq += diff * diff;
        }
        
        double stdDev = MathSqrt(sumSq / InpBBPeriod);
        BBStdDevBuffer[i] = stdDev;
        
        // Calculate Bollinger Bands
        BBUpperBuffer[i] = ma + (InpBBDeviation * stdDev);
        BBLowerBuffer[i] = ma - (InpBBDeviation * stdDev);
        
        // Ensure bands stay within RSI range [0, 100]
        BBUpperBuffer[i] = MathMin(BBUpperBuffer[i], 100);
        BBLowerBuffer[i] = MathMax(BBLowerBuffer[i], 0);
    }
}

//+------------------------------------------------------------------+
//| Calculate Z-Score with dynamic or static thresholds              |
//+------------------------------------------------------------------+
void CalculateZScore(const int rates_total, const int start)
{
    for(int i = start; i < rates_total; i++)
    {
        if(i < InpRSIPeriod + InpZScorePeriod - 1)
        {
            ZScoreUpperBuffer[i] = 70;
            ZScoreLowerBuffer[i] = 30;
            ZScoreMeanBuffer[i] = 50;
            continue;
        }
        
        // Calculate Mean of RSI
        double sum = 0;
        for(int j = 0; j < InpZScorePeriod; j++)
            sum += RSISmoothedBuffer[i - j];
        
        double mean = sum / InpZScorePeriod;
        ZScoreMeanBuffer[i] = mean;
        ZScoreMeanWork[i] = mean;
        
        // Calculate Standard Deviation
        double sumSq = 0;
        for(int j = 0; j < InpZScorePeriod; j++)
        {
            double diff = RSISmoothedBuffer[i - j] - mean;
            sumSq += diff * diff;
        }
        
        double stdDev = MathSqrt(sumSq / InpZScorePeriod);
        ZScoreStdDevWork[i] = stdDev;
        
        // Apply dynamic or static threshold
        double threshold = InpZScoreThreshold;
        if(InpZScoreDynamic && stdDev > 0)
        {
            // Adjust threshold based on volatility
            threshold = InpZScoreThreshold * (1 + (stdDev / 10.0));
        }
        
        // Calculate Z-Score boundaries
        ZScoreUpperBuffer[i] = mean + (threshold * stdDev);
        ZScoreLowerBuffer[i] = mean - (threshold * stdDev);
        
        // Ensure boundaries stay within valid RSI range
        ZScoreUpperBuffer[i] = MathMin(ZScoreUpperBuffer[i], 100);
        ZScoreLowerBuffer[i] = MathMax(ZScoreLowerBuffer[i], 0);
    }
}

//+------------------------------------------------------------------+
//| Calculate Fractal patterns on RSI                                |
//+------------------------------------------------------------------+
void CalculateFractals(const int rates_total, const int start)
{
    int halfPeriod = InpFractalPeriod / 2;
    
    for(int i = start; i < rates_total; i++)
    {
        FractalUpBuffer[i] = 0;
        FractalDownBuffer[i] = 0;
        
        if(i < InpRSIPeriod + halfPeriod || i >= rates_total - halfPeriod)
            continue;
        
        // Check for Bullish Fractal (RSI local minimum - potential reversal up)
        bool isBullishFractal = true;
        double centerValue = RSISmoothedBuffer[i];
        
        for(int j = 1; j <= halfPeriod; j++)
        {
            if(centerValue >= RSISmoothedBuffer[i - j] || centerValue >= RSISmoothedBuffer[i + j])
            {
                isBullishFractal = false;
                break;
            }
        }
        
        // Additional confirmation for fractals
        if(isBullishFractal)
        {
            if(!InpFractalConfirm || centerValue < 40)
                FractalUpBuffer[i] = centerValue;
        }
        
        // Check for Bearish Fractal (RSI local maximum - potential reversal down)
        bool isBearishFractal = true;
        
        for(int j = 1; j <= halfPeriod; j++)
        {
            if(centerValue <= RSISmoothedBuffer[i - j] || centerValue <= RSISmoothedBuffer[i + j])
            {
                isBearishFractal = false;
                break;
            }
        }
        
        // Additional confirmation for fractals
        if(isBearishFractal)
        {
            if(!InpFractalConfirm || centerValue > 60)
                FractalDownBuffer[i] = centerValue;
        }
    }
}

//+------------------------------------------------------------------+
//| Detect bullish and bearish divergences                           |
//+------------------------------------------------------------------+
void DetectDivergences(const int rates_total, const int start, 
                       const double &high[], const double &low[])
{
    int lookback = 20; // Bars to look back for divergence
    
    for(int i = start; i < rates_total; i++)
    {
        DivergenceWork[i] = 0; // 0=none, 1=bullish, -1=bearish
        
        if(i < InpRSIPeriod + lookback)
            continue;
        
        // Find recent price and RSI extremes
        int priceHighIdx = i;
        int priceLowIdx = i;
        int rsiHighIdx = i;
        int rsiLowIdx = i;
        
        for(int j = 1; j < lookback; j++)
        {
            if(high[i - j] > high[priceHighIdx])
                priceHighIdx = i - j;
            if(low[i - j] < low[priceLowIdx])
                priceLowIdx = i - j;
            if(RSISmoothedBuffer[i - j] > RSISmoothedBuffer[rsiHighIdx])
                rsiHighIdx = i - j;
            if(RSISmoothedBuffer[i - j] < RSISmoothedBuffer[rsiLowIdx])
                rsiLowIdx = i - j;
        }
        
        // Bullish Divergence: Price makes lower low, RSI makes higher low
        if(priceLowIdx > 5 && rsiLowIdx > 5)
        {
            if(low[i] < low[priceLowIdx] && RSISmoothedBuffer[i] > RSISmoothedBuffer[rsiLowIdx])
                DivergenceWork[i] = 1;
        }
        
        // Bearish Divergence: Price makes higher high, RSI makes lower high
        if(priceHighIdx > 5 && rsiHighIdx > 5)
        {
            if(high[i] > high[priceHighIdx] && RSISmoothedBuffer[i] < RSISmoothedBuffer[rsiHighIdx])
                DivergenceWork[i] = -1;
        }
    }
}

//+------------------------------------------------------------------+
//| Generate advanced multi-level trading signals                    |
//+------------------------------------------------------------------+
void GenerateAdvancedSignals(const int rates_total, const int start)
{
    for(int i = start; i < rates_total; i++)
    {
        // Reset all signal buffers
        BuySignal1Buffer[i] = 0;
        BuySignal2Buffer[i] = 0;
        BuySignal3Buffer[i] = 0;
        SellSignal1Buffer[i] = 0;
        SellSignal2Buffer[i] = 0;
        SellSignal3Buffer[i] = 0;
        SignalStrengthBuffer[i] = 0;
        
        int minRequiredBars = InpRSIPeriod + MathMax(InpBBPeriod, InpZScorePeriod) + InpFractalPeriod;
        if(i < minRequiredBars)
            continue;
        
        int buySignalCount = 0;
        int sellSignalCount = 0;
        double buySignalStrength = 0;
        double sellSignalStrength = 0;
        
        // === BUY SIGNAL CONDITIONS ===
        
        // Condition 1: Bollinger Band Lower Breakout
        if(InpShowBBSignals)
        {
            if(RSISmoothedBuffer[i] < BBLowerBuffer[i] && 
               RSISmoothedBuffer[i - 1] >= BBLowerBuffer[i - 1])
            {
                buySignalCount++;
                buySignalStrength += 1.5;
            }
            // Enhanced: RSI deep in oversold BB territory
            if(RSISmoothedBuffer[i] < BBLowerBuffer[i] - BBStdDevBuffer[i])
            {
                buySignalCount++;
                buySignalStrength += 2.0;
            }
        }
        
        // Condition 2: Z-Score Extreme Low
        if(InpShowZScoreSignals)
        {
            if(RSISmoothedBuffer[i] < ZScoreLowerBuffer[i] && 
               RSISmoothedBuffer[i - 1] >= ZScoreLowerBuffer[i - 1])
            {
                buySignalCount++;
                buySignalStrength += 1.5;
            }
            // Enhanced: Extreme Z-Score deviation
            if(ZScoreStdDevWork[i] > 0)
            {
                double zScore = (RSISmoothedBuffer[i] - ZScoreMeanWork[i]) / ZScoreStdDevWork[i];
                if(zScore < -InpZScoreThreshold)
                {
                    buySignalCount++;
                    buySignalStrength += 2.0;
                }
            }
        }
        
        // Condition 3: Bullish Fractal Signal
        if(InpShowFractalSignals && FractalUpBuffer[i] > 0)
        {
            buySignalCount++;
            buySignalStrength += 1.0;
        }
        
        // Condition 4: Bullish Divergence
        if(InpShowDivergence && DivergenceWork[i] == 1)
        {
            buySignalCount++;
            buySignalStrength += 2.5;
        }
        
        // Condition 5: RSI Oversold (below 30)
        if(RSISmoothedBuffer[i] < 30 && RSISmoothedBuffer[i - 1] >= 30)
        {
            buySignalCount++;
            buySignalStrength += 1.0;
        }
        
        // Condition 6: RSI Extreme Oversold (below 20)
        if(RSISmoothedBuffer[i] < 20)
        {
            buySignalCount++;
            buySignalStrength += 2.0;
        }
        
        // Condition 7: RSI Turning Up
        if(RSISmoothedBuffer[i] > RSISmoothedBuffer[i - 1] && 
           RSISmoothedBuffer[i - 1] <= RSISmoothedBuffer[i - 2])
        {
            buySignalStrength += 0.5;
        }
        
        // === SELL SIGNAL CONDITIONS ===
        
        // Condition 1: Bollinger Band Upper Breakout
        if(InpShowBBSignals)
        {
            if(RSISmoothedBuffer[i] > BBUpperBuffer[i] && 
               RSISmoothedBuffer[i - 1] <= BBUpperBuffer[i - 1])
            {
                sellSignalCount++;
                sellSignalStrength += 1.5;
            }
            // Enhanced: RSI deep in overbought BB territory
            if(RSISmoothedBuffer[i] > BBUpperBuffer[i] + BBStdDevBuffer[i])
            {
                sellSignalCount++;
                sellSignalStrength += 2.0;
            }
        }
        
        // Condition 2: Z-Score Extreme High
        if(InpShowZScoreSignals)
        {
            if(RSISmoothedBuffer[i] > ZScoreUpperBuffer[i] && 
               RSISmoothedBuffer[i - 1] <= ZScoreUpperBuffer[i - 1])
            {
                sellSignalCount++;
                sellSignalStrength += 1.5;
            }
            // Enhanced: Extreme Z-Score deviation
            if(ZScoreStdDevWork[i] > 0)
            {
                double zScore = (RSISmoothedBuffer[i] - ZScoreMeanWork[i]) / ZScoreStdDevWork[i];
                if(zScore > InpZScoreThreshold)
                {
                    sellSignalCount++;
                    sellSignalStrength += 2.0;
                }
            }
        }
        
        // Condition 3: Bearish Fractal Signal
        if(InpShowFractalSignals && FractalDownBuffer[i] > 0)
        {
            sellSignalCount++;
            sellSignalStrength += 1.0;
        }
        
        // Condition 4: Bearish Divergence
        if(InpShowDivergence && DivergenceWork[i] == -1)
        {
            sellSignalCount++;
            sellSignalStrength += 2.5;
        }
        
        // Condition 5: RSI Overbought (above 70)
        if(RSISmoothedBuffer[i] > 70 && RSISmoothedBuffer[i - 1] <= 70)
        {
            sellSignalCount++;
            sellSignalStrength += 1.0;
        }
        
        // Condition 6: RSI Extreme Overbought (above 80)
        if(RSISmoothedBuffer[i] > 80)
        {
            sellSignalCount++;
            sellSignalStrength += 2.0;
        }
        
        // Condition 7: RSI Turning Down
        if(RSISmoothedBuffer[i] < RSISmoothedBuffer[i - 1] && 
           RSISmoothedBuffer[i - 1] >= RSISmoothedBuffer[i - 2])
        {
            sellSignalStrength += 0.5;
        }
        
        // === ASSIGN SIGNAL LEVELS BASED ON COUNT AND STRENGTH ===
        
        // Buy Signal Classification
        if(buySignalCount >= 1)
        {
            if(buySignalCount == 1 || buySignalStrength < 3.0)
                BuySignal1Buffer[i] = RSISmoothedBuffer[i] - 7;
            else if(buySignalCount == 2 || (buySignalStrength >= 3.0 && buySignalStrength < 5.0))
                BuySignal2Buffer[i] = RSISmoothedBuffer[i] - 7;
            else if(buySignalCount >= 3 || buySignalStrength >= 5.0)
                BuySignal3Buffer[i] = RSISmoothedBuffer[i] - 7;
            
            SignalStrengthBuffer[i] = buySignalStrength;
        }
        
        // Sell Signal Classification
        if(sellSignalCount >= 1)
        {
            if(sellSignalCount == 1 || sellSignalStrength < 3.0)
                SellSignal1Buffer[i] = RSISmoothedBuffer[i] + 7;
            else if(sellSignalCount == 2 || (sellSignalStrength >= 3.0 && sellSignalStrength < 5.0))
                SellSignal2Buffer[i] = RSISmoothedBuffer[i] + 7;
            else if(sellSignalCount >= 3 || sellSignalStrength >= 5.0)
                SellSignal3Buffer[i] = RSISmoothedBuffer[i] + 7;
            
            SignalStrengthBuffer[i] = -sellSignalStrength;
        }
    }
}

//+------------------------------------------------------------------+
//| Draw enhanced visual signals on main chart                       |
//+------------------------------------------------------------------+
void DrawEnhancedChartSignals(const int rates_total, const int start,
                              const datetime &time[], const double &high[],
                              const double &low[], const double &close[])
{
    for(int i = start; i < rates_total; i++)
    {
        // Clean up old objects for this bar
        string prefix[] = {"BuyL1_", "BuyL2_", "BuyL3_", "SellL1_", "SellL2_", "SellL3_",
                          "BuyText_", "SellText_", "BuyFlag_", "SellFlag_"};
        
        for(int p = 0; p < ArraySize(prefix); p++)
        {
            string objName = prefix[p] + IntegerToString(i);
            ObjectDelete(0, objName);
        }
        
        // Calculate offset for visual elements
        double atr = 0;
        if(i >= 14)
        {
            for(int j = 0; j < 14; j++)
                atr += high[i - j] - low[i - j];
            atr /= 14;
        }
        else
            atr = (high[i] - low[i]) * 2;
        
        double arrowOffset = atr * 0.3;
        double textOffset = atr * 0.5;
        double flagOffset = atr * 0.7;
        
        // === Draw BUY Signals ===
        
        // Buy Level 1 (Weak Signal)
        if(BuySignal1Buffer[i] > 0)
        {
            string objName = "BuyL1_" + IntegerToString(i);
            ObjectCreate(0, objName, OBJ_ARROW, 0, time[i], low[i] - arrowOffset);
            ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, 233);
            ObjectSetInteger(0, objName, OBJPROP_COLOR, clrLightGreen);
            ObjectSetInteger(0, objName, OBJPROP_WIDTH, InpSignalArrowSize);
            ObjectSetInteger(0, objName, OBJPROP_BACK, false);
            ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
        }
        
        // Buy Level 2 (Medium Signal) - More Visible
        if(BuySignal2Buffer[i] > 0)
        {
            string objName = "BuyL2_" + IntegerToString(i);
            ObjectCreate(0, objName, OBJ_ARROW, 0, time[i], low[i] - arrowOffset);
            ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, 241);
            ObjectSetInteger(0, objName, OBJPROP_COLOR, clrLime);
            ObjectSetInteger(0, objName, OBJPROP_WIDTH, InpSignalArrowSize + 2);
            ObjectSetInteger(0, objName, OBJPROP_BACK, false);
            ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
            
            // Add text label for Level 2
            if(InpShowTextLabels)
            {
                string textName = "BuyText_" + IntegerToString(i);
                ObjectCreate(0, textName, OBJ_TEXT, 0, time[i], low[i] - textOffset);
                ObjectSetString(0, textName, OBJPROP_TEXT, "BUY L2");
                ObjectSetInteger(0, textName, OBJPROP_COLOR, InpBuyTextColor);
                ObjectSetInteger(0, textName, OBJPROP_FONTSIZE, InpFontSize);
                ObjectSetString(0, textName, OBJPROP_FONT, "Arial Bold");
                ObjectSetInteger(0, textName, OBJPROP_ANCHOR, ANCHOR_UPPER);
                ObjectSetInteger(0, textName, OBJPROP_BACK, false);
                ObjectSetInteger(0, textName, OBJPROP_SELECTABLE, false);
            }
        }
        
        // Buy Level 3 (Strong Signal) - HIGHLY Visible with Flag
        if(BuySignal3Buffer[i] > 0)
        {
            string objName = "BuyL3_" + IntegerToString(i);
            ObjectCreate(0, objName, OBJ_ARROW, 0, time[i], low[i] - arrowOffset);
            ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, 226);
            ObjectSetInteger(0, objName, OBJPROP_COLOR, clrDarkGreen);
            ObjectSetInteger(0, objName, OBJPROP_WIDTH, InpSignalArrowSize + 3);
            ObjectSetInteger(0, objName, OBJPROP_BACK, false);
            ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
            
            // Add prominent text label for Level 3
            if(InpShowTextLabels)
            {
                string textName = "BuyText_" + IntegerToString(i);
                ObjectCreate(0, textName, OBJ_TEXT, 0, time[i], low[i] - textOffset);
                ObjectSetString(0, textName, OBJPROP_TEXT, "★ STRONG BUY ★");
                ObjectSetInteger(0, textName, OBJPROP_COLOR, clrLime);
                ObjectSetInteger(0, textName, OBJPROP_FONTSIZE, InpFontSize + 2);
                ObjectSetString(0, textName, OBJPROP_FONT, "Arial Black");
                ObjectSetInteger(0, textName, OBJPROP_ANCHOR, ANCHOR_UPPER);
                ObjectSetInteger(0, textName, OBJPROP_BACK, false);
                ObjectSetInteger(0, textName, OBJPROP_SELECTABLE, false);
            }
            
            // Add flag marker for Level 3
            string flagName = "BuyFlag_" + IntegerToString(i);
            ObjectCreate(0, flagName, OBJ_ARROW, 0, time[i], low[i] - flagOffset);
            ObjectSetInteger(0, flagName, OBJPROP_ARROWCODE, 8);
            ObjectSetInteger(0, flagName, OBJPROP_COLOR, clrLime);
            ObjectSetInteger(0, flagName, OBJPROP_WIDTH, 4);
            ObjectSetInteger(0, flagName, OBJPROP_BACK, true);
            ObjectSetInteger(0, flagName, OBJPROP_SELECTABLE, false);
        }
        
        // === Draw SELL Signals ===
        
        // Sell Level 1 (Weak Signal)
        if(SellSignal1Buffer[i] > 0)
        {
            string objName = "SellL1_" + IntegerToString(i);
            ObjectCreate(0, objName, OBJ_ARROW, 0, time[i], high[i] + arrowOffset);
            ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, 234);
            ObjectSetInteger(0, objName, OBJPROP_COLOR, clrLightCoral);
            ObjectSetInteger(0, objName, OBJPROP_WIDTH, InpSignalArrowSize);
            ObjectSetInteger(0, objName, OBJPROP_BACK, false);
            ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
        }
        
        // Sell Level 2 (Medium Signal) - More Visible
        if(SellSignal2Buffer[i] > 0)
        {
            string objName = "SellL2_" + IntegerToString(i);
            ObjectCreate(0, objName, OBJ_ARROW, 0, time[i], high[i] + arrowOffset);
            ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, 242);
            ObjectSetInteger(0, objName, OBJPROP_COLOR, clrOrangeRed);
            ObjectSetInteger(0, objName, OBJPROP_WIDTH, InpSignalArrowSize + 2);
            ObjectSetInteger(0, objName, OBJPROP_BACK, false);
            ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
            
            // Add text label for Level 2
            if(InpShowTextLabels)
            {
                string textName = "SellText_" + IntegerToString(i);
                ObjectCreate(0, textName, OBJ_TEXT, 0, time[i], high[i] + textOffset);
                ObjectSetString(0, textName, OBJPROP_TEXT, "SELL L2");
                ObjectSetInteger(0, textName, OBJPROP_COLOR, InpSellTextColor);
                ObjectSetInteger(0, textName, OBJPROP_FONTSIZE, InpFontSize);
                ObjectSetString(0, textName, OBJPROP_FONT, "Arial Bold");
                ObjectSetInteger(0, textName, OBJPROP_ANCHOR, ANCHOR_LOWER);
                ObjectSetInteger(0, textName, OBJPROP_BACK, false);
                ObjectSetInteger(0, textName, OBJPROP_SELECTABLE, false);
            }
        }
        
        // Sell Level 3 (Strong Signal) - HIGHLY Visible with Flag
        if(SellSignal3Buffer[i] > 0)
        {
            string objName = "SellL3_" + IntegerToString(i);
            ObjectCreate(0, objName, OBJ_ARROW, 0, time[i], high[i] + arrowOffset);
            ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, 225);
            ObjectSetInteger(0, objName, OBJPROP_COLOR, clrDarkRed);
            ObjectSetInteger(0, objName, OBJPROP_WIDTH, InpSignalArrowSize + 3);
            ObjectSetInteger(0, objName, OBJPROP_BACK, false);
            ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
            
            // Add prominent text label for Level 3
            if(InpShowTextLabels)
            {
                string textName = "SellText_" + IntegerToString(i);
                ObjectCreate(0, textName, OBJ_TEXT, 0, time[i], high[i] + textOffset);
                ObjectSetString(0, textName, OBJPROP_TEXT, "★ STRONG SELL ★");
                ObjectSetInteger(0, textName, OBJPROP_COLOR, clrRed);
                ObjectSetInteger(0, textName, OBJPROP_FONTSIZE, InpFontSize + 2);
                ObjectSetString(0, textName, OBJPROP_FONT, "Arial Black");
                ObjectSetInteger(0, textName, OBJPROP_ANCHOR, ANCHOR_LOWER);
                ObjectSetInteger(0, textName, OBJPROP_BACK, false);
                ObjectSetInteger(0, textName, OBJPROP_SELECTABLE, false);
            }
            
            // Add flag marker for Level 3
            string flagName = "SellFlag_" + IntegerToString(i);
            ObjectCreate(0, flagName, OBJ_ARROW, 0, time[i], high[i] + flagOffset);
            ObjectSetInteger(0, flagName, OBJPROP_ARROWCODE, 8);
            ObjectSetInteger(0, flagName, OBJPROP_COLOR, clrRed);
            ObjectSetInteger(0, flagName, OBJPROP_WIDTH, 4);
            ObjectSetInteger(0, flagName, OBJPROP_BACK, true);
            ObjectSetInteger(0, flagName, OBJPROP_SELECTABLE, false);
        }
    }
}

//+------------------------------------------------------------------+
//| Check and trigger alerts for new signals                         |
//+------------------------------------------------------------------+
void CheckAndTriggerAlerts(const int rates_total, const datetime &time[])
{
    if(rates_total < 2)
        return;
    
    int currentBar = rates_total - 1;
    
    // Prevent duplicate alerts for the same bar
    if(time[currentBar] == LastAlertTime)
        return;
    
    string alertMsg = "";
    
    // Check for Buy Signals
    if(BuySignal3Buffer[currentBar] > 0)
    {
        alertMsg = "STRONG BUY SIGNAL (Level 3) - " + Symbol() + " " + 
                   EnumToString((ENUM_TIMEFRAMES)Period());
        LastAlertTime = time[currentBar];
    }
    else if(BuySignal2Buffer[currentBar] > 0)
    {
        alertMsg = "MEDIUM BUY SIGNAL (Level 2) - " + Symbol() + " " + 
                   EnumToString((ENUM_TIMEFRAMES)Period());
        LastAlertTime = time[currentBar];
    }
    else if(BuySignal1Buffer[currentBar] > 0)
    {
        alertMsg = "Buy Signal (Level 1) - " + Symbol() + " " + 
                   EnumToString((ENUM_TIMEFRAMES)Period());
        LastAlertTime = time[currentBar];
    }
    
    // Check for Sell Signals
    if(SellSignal3Buffer[currentBar] > 0)
    {
        alertMsg = "STRONG SELL SIGNAL (Level 3) - " + Symbol() + " " + 
                   EnumToString((ENUM_TIMEFRAMES)Period());
        LastAlertTime = time[currentBar];
    }
    else if(SellSignal2Buffer[currentBar] > 0)
    {
        alertMsg = "MEDIUM SELL SIGNAL (Level 2) - " + Symbol() + " " + 
                   EnumToString((ENUM_TIMEFRAMES)Period());
        LastAlertTime = time[currentBar];
    }
    else if(SellSignal1Buffer[currentBar] > 0)
    {
        alertMsg = "Sell Signal (Level 1) - " + Symbol() + " " + 
                   EnumToString((ENUM_TIMEFRAMES)Period());
        LastAlertTime = time[currentBar];
    }
    
    // Trigger alert if message exists
    if(alertMsg != "")
    {
        Alert(alertMsg);
        Print(alertMsg);
        
        // Optional: Send notification (requires enabling in MT5 settings)
        // SendNotification(alertMsg);
    }
}

//+------------------------------------------------------------------+
//| Custom indicator deinitialization function                       |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Clean up all chart objects created by this indicator
    int total = ObjectsTotal(0, 0, OBJ_ARROW);
    for(int i = total - 1; i >= 0; i--)
    {
        string objName = ObjectName(0, i, 0, OBJ_ARROW);
        if(StringFind(objName, "Buy") >= 0 || StringFind(objName, "Sell") >= 0)
        {
            ObjectDelete(0, objName);
        }
    }
    
    total = ObjectsTotal(0, 0, OBJ_TEXT);
    for(int i = total - 1; i >= 0; i--)
    {
        string objName = ObjectName(0, i, 0, OBJ_TEXT);
        if(StringFind(objName, "Buy") >= 0 || StringFind(objName, "Sell") >= 0)
        {
            ObjectDelete(0, objName);
        }
    }
    
    Comment("");
    
    string deactivationReason;
    switch(reason)
    {
        case REASON_PROGRAM:     deactivationReason = "Program terminated"; break;
        case REASON_REMOVE:      deactivationReason = "Indicator removed"; break;
        case REASON_RECOMPILE:   deactivationReason = "Indicator recompiled"; break;
        case REASON_CHARTCHANGE: deactivationReason = "Chart changed"; break;
        case REASON_CHARTCLOSE:  deactivationReason = "Chart closed"; break;
        case REASON_PARAMETERS:  deactivationReason = "Parameters changed"; break;
        case REASON_ACCOUNT:     deactivationReason = "Account changed"; break;
        default:                 deactivationReason = "Unknown reason"; break;
    }
    
    Print("RSI Multi-Signal System deinitialized. Reason: ", deactivationReason);
}
//+------------------------------------------------------------------+
